<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MoonBit UI - Browser Benchmark</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
      margin: 0;
      padding: 20px;
      background: #1a1a2e;
      color: #eee;
    }
    h1 { color: #fff; margin-bottom: 10px; }
    .subtitle { color: #888; margin-bottom: 20px; }
    #controls {
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    button {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      background: #4a4a8a;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover { background: #5a5a9a; }
    button:disabled { background: #333; cursor: not-allowed; }
    #results {
      background: #16213e;
      border-radius: 8px;
      padding: 20px;
      font-family: monospace;
      white-space: pre-wrap;
      line-height: 1.6;
      max-height: 70vh;
      overflow-y: auto;
    }
    .section { color: #7ec8e3; font-weight: bold; }
    .bench-name { color: #98d8c8; }
    .bench-time { color: #f7dc6f; }
    .status { color: #aaa; }
    #container { display: none; }
    .comparison { margin-top: 20px; padding: 15px; background: #0f3460; border-radius: 8px; }
    .comparison h3 { margin: 0 0 10px 0; color: #7ec8e3; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 8px; text-align: left; border-bottom: 1px solid #333; }
    th { color: #7ec8e3; }
    .faster { color: #2ecc71; }
    .slower { color: #e74c3c; }
  </style>
</head>
<body>
  <h1>MoonBit UI Browser Benchmark</h1>
  <p class="subtitle">Real browser DOM performance (no jsdom/happy-dom)</p>

  <div id="controls">
    <button id="runBtn">Run Benchmark</button>
    <label>
      Iterations:
      <select id="iterations">
        <option value="100">100</option>
        <option value="500">500</option>
        <option value="1000" selected>1000</option>
        <option value="5000">5000</option>
      </select>
    </label>
    <span id="status" class="status"></span>
  </div>

  <div id="results">Click "Run Benchmark" to start...</div>

  <div id="container"></div>

  <script type="module">
    import {
      createSignal,
      get,
      set,
      effect,
      batch,
      createMemo,
      createRoot,
    } from "../target/js/release/build/js/api/api.js";
    import {
      div,
      span,
      text,
      render,
      mount,
      className,
    } from "../target/js/release/build/js/dom/dom.js";

    const resultsEl = document.getElementById("results");
    const statusEl = document.getElementById("status");
    const runBtn = document.getElementById("runBtn");
    const iterationsSelect = document.getElementById("iterations");
    const container = document.getElementById("container");

    let ITERATIONS = 1000;
    const WARMUP = 50;

    const results = [];

    function log(text, className = "") {
      const span = document.createElement("span");
      span.className = className;
      span.textContent = text + "\n";
      resultsEl.appendChild(span);
      resultsEl.scrollTop = resultsEl.scrollHeight;
    }

    function bench(name, fn) {
      // Warmup
      for (let i = 0; i < WARMUP; i++) {
        fn();
      }

      // Actual run
      const start = performance.now();
      for (let i = 0; i < ITERATIONS; i++) {
        fn();
      }
      const elapsed = performance.now() - start;
      const perOp = elapsed / ITERATIONS;

      results.push({ name, elapsed, perOp });

      log(`${name}: `, "bench-name");
      log(`  ${elapsed.toFixed(2)}ms total, ${perOp.toFixed(4)}ms/op`, "bench-time");
    }

    function createListNode(count) {
      const items = [];
      for (let i = 0; i < count; i++) {
        items.push(div([], [text(`Item ${i}`)]));
      }
      return div([], items);
    }

    function createNestedNode(depth) {
      let node = text("leaf");
      for (let i = 0; i < depth; i++) {
        node = div([], [node]);
      }
      return node;
    }

    function createListNodeWithAttrs(count) {
      const items = [];
      for (let i = 0; i < count; i++) {
        items.push(div([className(`item-${i}`)], [text(`Item ${i}`)]));
      }
      return div([className("list")], items);
    }

    async function runBenchmarks() {
      results.length = 0;
      resultsEl.innerHTML = "";
      ITERATIONS = parseInt(iterationsSelect.value);

      log(`=== MoonBit UI Browser Benchmarks ===`, "section");
      log(`Iterations: ${ITERATIONS}, Warmup: ${WARMUP}`, "status");
      log("");

      // Give UI time to update
      await new Promise(r => setTimeout(r, 10));

      // Signal benchmarks
      log("--- Signal Operations ---", "section");
      statusEl.textContent = "Running signal benchmarks...";
      await new Promise(r => setTimeout(r, 1));

      bench("createSignal", () => {
        createSignal(0);
      });

      bench("signal_get_10x", () => {
        createRoot(() => {
          const sig = createSignal(0);
          for (let i = 0; i < 10; i++) {
            get(sig);
          }
        });
      });

      bench("signal_set_10x", () => {
        createRoot(() => {
          const sig = createSignal(0);
          for (let i = 0; i < 10; i++) {
            set(sig, i);
          }
        });
      });

      bench("effect_creation", () => {
        createRoot(() => {
          const sig = createSignal(0);
          effect(() => {
            get(sig);
          });
        });
      });

      bench("effect_trigger_10x", () => {
        createRoot(() => {
          const sig = createSignal(0);
          let count = 0;
          effect(() => {
            get(sig);
            count++;
          });
          for (let i = 0; i < 10; i++) {
            set(sig, i);
          }
        });
      });

      bench("batch_updates", () => {
        createRoot(() => {
          const sig1 = createSignal(0);
          const sig2 = createSignal(0);
          const sig3 = createSignal(0);
          let count = 0;
          effect(() => {
            get(sig1);
            get(sig2);
            get(sig3);
            count++;
          });
          batch(() => {
            set(sig1, 1);
            set(sig2, 2);
            set(sig3, 3);
          });
        });
      });

      bench("memo_creation", () => {
        createRoot(() => {
          const sig = createSignal(0);
          createMemo(() => get(sig) * 2);
        });
      });

      bench("memo_chain_5", () => {
        createRoot(() => {
          const sig = createSignal(0);
          const m1 = createMemo(() => get(sig) + 1);
          const m2 = createMemo(() => m1() * 2);
          const m3 = createMemo(() => m2() + 1);
          const m4 = createMemo(() => m3() * 2);
          const m5 = createMemo(() => m4() + 1);
          m5();
        });
      });

      await new Promise(r => setTimeout(r, 1));

      // VNode creation benchmarks
      log("");
      log("--- VNode Creation ---", "section");
      statusEl.textContent = "Running VNode benchmarks...";
      await new Promise(r => setTimeout(r, 1));

      bench("vnode_simple", () => {
        div([], [text("Hello")]);
      });

      bench("vnode_with_attrs", () => {
        div([className("container")], [text("Hello")]);
      });

      bench("vnode_list_10", () => {
        createListNode(10);
      });

      bench("vnode_list_50", () => {
        createListNode(50);
      });

      bench("vnode_list_100", () => {
        createListNode(100);
      });

      bench("vnode_list_with_attrs_50", () => {
        createListNodeWithAttrs(50);
      });

      bench("vnode_nested_10", () => {
        createNestedNode(10);
      });

      bench("vnode_nested_50", () => {
        createNestedNode(50);
      });

      await new Promise(r => setTimeout(r, 1));

      // DOM rendering benchmarks
      log("");
      log("--- DOM Rendering ---", "section");
      statusEl.textContent = "Running DOM benchmarks...";
      await new Promise(r => setTimeout(r, 1));

      bench("render_simple", () => {
        const node = div([], [text("Hello")]);
        render(container, node);
      });

      bench("render_with_attrs", () => {
        const node = div([className("container")], [text("Hello")]);
        render(container, node);
      });

      bench("render_list_10", () => {
        const node = createListNode(10);
        render(container, node);
      });

      bench("render_list_50", () => {
        const node = createListNode(50);
        render(container, node);
      });

      bench("render_list_100", () => {
        const node = createListNode(100);
        render(container, node);
      });

      bench("render_nested_10", () => {
        const node = createNestedNode(10);
        render(container, node);
      });

      // Mount only (no clear) benchmarks
      log("");
      log("--- DOM Mount (no clear) ---", "section");

      bench("mount_simple", () => {
        const node = div([], [text("Hello")]);
        mount(container, node);
        container.innerHTML = "";
      });

      bench("mount_list_50", () => {
        const node = createListNode(50);
        mount(container, node);
        container.innerHTML = "";
      });

      // moveBefore benchmarks (if supported)
      log("");
      log("--- moveBefore API ---", "section");

      const moveBeforeSupported = typeof Element.prototype.moveBefore === 'function';
      log(`moveBefore supported: ${moveBeforeSupported}`, "status");

      if (moveBeforeSupported) {
        // Setup: create a list of elements
        const setupMoveBeforeList = (count) => {
          const ul = document.createElement("ul");
          for (let i = 0; i < count; i++) {
            const li = document.createElement("li");
            li.textContent = `Item ${i}`;
            ul.appendChild(li);
          }
          container.appendChild(ul);
          return ul;
        };

        bench("moveBefore_single", () => {
          const ul = setupMoveBeforeList(10);
          const firstChild = ul.firstChild;
          // Move first to last
          ul.moveBefore(firstChild, null);
          container.innerHTML = "";
        });

        bench("insertBefore_single", () => {
          const ul = setupMoveBeforeList(10);
          const firstChild = ul.firstChild;
          // Move first to last (using insertBefore)
          ul.insertBefore(firstChild, null);
          container.innerHTML = "";
        });

        bench("moveBefore_shuffle_10", () => {
          const ul = setupMoveBeforeList(10);
          const children = Array.from(ul.children);
          // Reverse order using moveBefore
          for (let i = children.length - 1; i >= 0; i--) {
            ul.moveBefore(children[i], ul.firstChild);
          }
          container.innerHTML = "";
        });

        bench("insertBefore_shuffle_10", () => {
          const ul = setupMoveBeforeList(10);
          const children = Array.from(ul.children);
          // Reverse order using insertBefore
          for (let i = children.length - 1; i >= 0; i--) {
            ul.insertBefore(children[i], ul.firstChild);
          }
          container.innerHTML = "";
        });
      } else {
        log("Skipping moveBefore benchmarks (not supported in this browser)", "status");
        log("moveBefore is available in Chrome 133+", "status");
      }

      log("");
      log("=== Benchmark Complete ===", "section");
      statusEl.textContent = "Done!";

      // Print JSON for easy copy
      log("");
      log("--- JSON Results ---", "section");
      log(JSON.stringify(results, null, 2), "status");
    }

    runBtn.addEventListener("click", async () => {
      runBtn.disabled = true;
      try {
        await runBenchmarks();
      } finally {
        runBtn.disabled = false;
      }
    });
  </script>
</body>
</html>
